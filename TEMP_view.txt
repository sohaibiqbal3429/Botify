import { type NextRequest, NextResponse } from "next/server"

import { getUserFromRequest } from "@/lib/auth"
import { isRedisEnabled } from "@/lib/redis"
import {
  enqueueMiningRequest,
  getMiningRequestStatus,
  isMiningQueueEnabled,
  MINING_STATUS_TTL_MS,
  type MiningRequestStatus,
} from "@/lib/services/mining-queue"
import { enforceUnifiedRateLimit, getClientIp, getRateLimitContext } from "@/lib/rate-limit/unified"
import { recordRequestLatency, trackRequestRate } from "@/lib/observability/request-metrics"

// ✅ CRITICAL: mongoose/transactions must run on node runtime
export const runtime = "nodejs"
export const dynamic = "force-dynamic"

function makeIdempotencyKey() {
  const g = globalThis as any
  if (g?.crypto?.randomUUID) return g.crypto.randomUUID()
  return `idem_${Date.now()}_${Math.random().toString(16).slice(2)}`
}

function withTimeout<T>(promise: Promise<T>, ms: number, label: string): Promise<T> {
  return new Promise<T>((resolve, reject) => {
    const id = setTimeout(() => reject(new Error(`${label} timeout after ${ms}ms`)), ms)
    promise
      .then((v) => resolve(v))
      .catch((e) => reject(e))
      .finally(() => clearTimeout(id))
  })
}

function buildStatusResponse(
  status: MiningRequestStatus,
  request: NextRequest,
  extraHeaders: Record<string, string> = {},
): NextResponse<{ status: MiningRequestStatus; statusUrl: string }> {
  const statusUrl = new URL("/api/mining/click/status", request.url)
  statusUrl.searchParams.set("key", status.idempotencyKey)

  let statusCode = 202
  const headers: Record<string, string> = {
    "Cache-Control": "no-store",
    "Idempotency-Key": status.idempotencyKey,
    ...extraHeaders,
  }

  if (status.status === "queued" || status.status === "processing") {
    if (status.queueDepth !== undefined) headers["X-Queue-Depth"] = String(status.queueDepth)
  } else if (status.status === "completed") {
    statusCode = 200
    headers["Cache-Control"] = `private, max-age=0, s-maxage=${Math.floor(MINING_STATUS_TTL_MS / 1000)}`
  } else {
    statusCode = status.error?.retryable ? 503 : 409
    if (status.error?.retryAfterMs) {
      const retrySeconds = Math.max(1, Math.ceil(status.error.retryAfterMs / 1000))
      headers["Retry-After"] = retrySeconds.toString()
    }
  }

  return NextResponse.json({ status, statusUrl: statusUrl.toString() }, { status: statusCode, headers })
}

export async function POST(request: NextRequest) {
  const startedAt = Date.now()
  const path = new URL(request.url).pathname
  const rateLimitContext = getRateLimitContext(request)
  trackRequestRate("backend", { path })

  const respond = (response: NextResponse, tags: Record<string, string | number> = {}) => {
    recordRequestLatency("backend", Date.now() - startedAt, { path, status: response.status, ...tags })
    return response
  }

  // 1) Rate limit
  const rateDecision = await enforceUnifiedRateLimit("backend", rateLimitContext, { path })
  if (!rateDecision.allowed && rateDecision.response) {
    return respond(rateDecision.response, { outcome: "rate_limited" })
  }

  // 2) Auth
  const userPayload = getUserFromRequest(request)
  if (!userPayload) {
    return respond(NextResponse.json({ error: "Unauthorized" }, { status: 401 }), { outcome: "unauthorized" })
  }

  // 3) Idempotency
  let idempotencyKey =
    request.headers.get("idempotency-key")?.trim() ||
    request.headers.get("Idempotency-Key")?.trim() ||
    ""
  if (!idempotencyKey) idempotencyKey = makeIdempotencyKey()

  const ip = getClientIp(request)

  // ✅ Queue is mandatory for non-blocking mining
  const queueAvailable = isRedisEnabled() && isMiningQueueEnabled()
  if (!queueAvailable) {
    return respond(
      NextResponse.json(
        { error: "Mining queue unavailable. Please try again soon." },
        { status: 503, headers: { "Idempotency-Key": idempotencyKey } },
      ),
      { outcome: "queue_unavailable" },
    )
  }

  // ✅ Redis status lookup can hang => timeout and fallback to direct
  let existingStatus: MiningRequestStatus | null = null
  try {
    existingStatus = await withTimeout(getMiningRequestStatus(idempotencyKey), 800, "getMiningRequestStatus")
  } catch (e) {
    console.warn("Redis status lookup timed out", e)
    return respond(
      NextResponse.json(
        { error: "Mining is temporarily unavailable. Please try again." },
        { status: 503, headers: { "Idempotency-Key": idempotencyKey } },
      ),
      { outcome: "status_timeout" },
    )
  }

  if (existingStatus) {
    if (existingStatus.userId !== userPayload.userId) {
      return respond(
        NextResponse.json({ error: "Idempotency key belongs to another user" }, { status: 409, headers: { "Idempotency-Key": idempotencyKey } }),
        { outcome: "idempotency_conflict" },
      )
    }
    return respond(buildStatusResponse(existingStatus, request), { outcome: "duplicate" })
  }

  // ✅ Enqueue can hang => timeout and fallback
  try {
    const enqueueResult = await withTimeout(
      enqueueMiningRequest({
        userId: userPayload.userId,
        idempotencyKey,
        sourceIp: ip,
        userAgent: request.headers.get("user-agent"),
      }),
      800,
      "enqueueMiningRequest",
    )

    return respond(buildStatusResponse(enqueueResult.status, request), { outcome: "enqueued" })
  } catch (error) {
    console.error("Mining click enqueue error/timeout", error)
    return respond(
      NextResponse.json(
        { error: "Unable to queue mining request. Please try again." },
        { status: 503, headers: { "Idempotency-Key": idempotencyKey } },
      ),
      { outcome: "enqueue_failure" },
    )
  }
}

